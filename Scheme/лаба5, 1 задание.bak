(define (index a)
  (char->integer a))
(define-syntax plus
  (syntax-rules ()
    ((_ a) (+ a 1))))
(define (prov-number a)
  (and (> (index a) (- (index #\0) 1)) (< (index a) (+ (index #\9) 1))))
(define (prov-bukva a)
  (and (> (index a) (- (index #\A) 1)) (< (index a) (+ (index #\F) 1))))
(define (check-hex a)
  (prov-shest (string->list a) (length (string->list a)) 1))
(define (prov-shest a n c)
  (define (ost a n c)
    (if (not (> c n))
        (cond
          ((prov-bukva (car a)) (ost (cdr a) n (plus c)))
          ((prov-number (car a)) (ost (cdr a) n (plus c)))
          (else #f))
        #t))
  (if (not (> c n))
      (if (and (equal? (index (car a)) (index #\0)) (equal? (index (cadr a)) (index #\x)))
          (ost (cddr a) (- n 2) c)
          #f)))
(define (scan-hex a)
  (define (scan-dex a s n)
    (if (equal? a '())
        s
        (cond
          ((prov-bukva (car a)) (scan-dex (cdr a) (+ s (* (expt 16 n) (+ (- (index (car a)) (index #\A)) 10))) (- n 1)))
          ((prov-number (car a)) (scan-dex (cdr a) (+ s (* (expt 16 n) (- (index (car a)) (index #\0)))) (- n 1))))))
  (if (not (check-hex a))
      #f
      (scan-dex (cddr(string->list a)) 0 (- (length (cddr(string->list a))) 1))))
(define (space? a)
  (cond
    ((equal? a #\space))
    ((equal? a #\tab))
    ((equal? a #\newline))))
 
(define (scan-many-hexs a)
  (scan-many-dexs (string->list a) '() '()))
(define (scan-many-dexs a str lst)
  (if (equal? a '())
      (find-false (reverse (cons (scan-hex (list->string (reverse str))) lst)) (reverse (cons (scan-hex (list->string (reverse str))) lst)))
      (if (equal? (car a) #\space)
          (scan-many-dexs (cdr a) '() (cons (scan-hex (list->string (reverse str))) lst ))
          (scan-many-dexs (cdr a) (cons (car a) str) lst))))
(define (find-false a c)
  (if (equal? c '())
      a
      (if (equal? (car c) #f)
          #f
          (find-false a (cdr c)))))
(scan-many-hexs "0xB 0xA 0xA")